<!DOCTYPE html>
<html>
  <head>
    <title>Выделение типов растительного покрова по восстановленным кривым спектральной яркости</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <style type="text/css">
      body { font-family: 'Arial'; }
      h1, h2, h3 {
        font-family: 'Arial';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Arial'; }

      .remark-slide-content h1 { font-size: 1.9em; }
      .remark-slide-content h2 { font-size: 1.5em; }
      .remark-slide-content h3 { font-size: 1.3em; }

      .inverse {
        background: #272822;
        color: #777872;
        text-shadow: 0 0 20px #333;
      }
      .inverse h1, .inverse h2 {
        color: #f3f3f3;
        line-height: 0.8em;
      }
      .inverse h3{
        color: #d0d0d0;
        line-height: 0.8em;
      }

      .small {font-size: 0.9em;}
      .tiny {font-size: 0.5em;}

      .footnote {font-size: 0.8em; color: #7070aa;}

      /* Two-column layout */
      .left-column {
        color: #000;
        width: 30%;
        height: 92%;
        float: left;
      }
      .left-column h2:last-of-type, .left-column h3:last-child {
          color: #000;
        }
      .right-column {
        width: 60%;
        float: right;
        padding-top: 1em;
      }

    </style>
    <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML&delayStartupUntil=configured" type="text/javascript"></script>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# Выделение типов растительного покрова по восстановленным кривы спектральной яркости
## (Принципы работы модуля GRASS r.series.decompose)
### Колесов Д.А., Филиппов И.В.

---

# Содержание

### 1. История вопроса
### 2. Используемые методы
### 3. Реализация и примеры 


---
# Исходная задача 
Выделение <<трудных>> типов растительного покрова

# Рабочая гипотеза
Разные типы растительных сообществ имеют свои фенологические особенности, которые
отражаются в форме кривых сезонных изменений спектральных яркостей и вегетационных индексов.

**Пример <<трудных классов>>:** Болота, поросшие березой и зарастающие березой гари.

Изначально рассматривалась задача классификации растительности по сериям NDVI.

# Задачи
 * Восстановление сезонного хода индекса NDVI (очистка от шумов).
 * Произвести классификацию типов растительного покрова по очищенным сериям NDVI.
 * Проверить точность классификации на <<трудных>> типах растительности.

???
Рассказать о начальной суперцели -- поиску уникальных местообитаний;
Уникальное местообитание - местообитание с редкими природными условиями. Они
косвенно отображаются в спектральных характеристиках участка. Для поиска
таких мест нужно определить небольшие по площади отличающиеся от общей массы
участки. В случае анализа исходных снимков такие участки приходятся не на действительно
уникальные места, а на участки снимка с тенями, неоднородностью атмосферы и т.п.


Существуют классы, которые трудно дешифрируются по единовременному снимку,
тогда мы берем несколько снимков, чтобы уловить динамику, но тогда шумы от нескольких
снимков "всплывают" и шумы мешают еще больше. Отсюда
возникает задача очистки ДЗЗ от шумов

---

## Классический подход к выделению типов растительного покрова по ДДЗЗ

.center[
![Спектральные кривые и пространство признаков](img/spectr.png
"Спектральные кривые и пространство признаков")
]

.center[Усредненные характеристические кривой отражательной способности
для различных объектов.]

.small[
* Различные объекты в разных лучах спектра выглядят по-разному, поэтому
съемка одновременно в нескольких областях спектра дает существенную информацию.
* Каждый пиксель, соответствующий координатам `\((x,y)\)` можно представить
в виде вектора значений яркости каждого отдельного изображения:
`$$
  \overline{P}(x,y) =
    \{b_1(x,y), b_2(x,y),
     \dots, b_n(x,y) \}
$$`
где `\(\overline{P}\)` - вектор яркостей,
`\(b_i(x,y)\)` - значение яркости по `\(i\)`-му каналу в точке с координатами `\((x,y)\)`.
]

???

    Кратко рассказать о том, как производится классификация ДЗЗ на основе
    мультиспектральных данных.

---
# Плюсы и минусы одномоментных снимков

## Плюсы
 * Хорошо изученные методы анализа снимков.
 * Проще интерпретировать данные.

## Минусы
 * Каждый одномоментный снимок делается в уникальных условиях (геометрия системы
Солнце - Земная поверхность - спутник; атмосферные условия; изменения Земной поверхности) =>
<<хорошие>> параметры анализа для одного снимка будут неоптимальны для другого.
 * Вследствие неоднородности атмосферы одинаковые объекты в разных частях снимка
могут быть отражены на нем по-разному.
 * Объект виден в статике и разные объекты могут выглядеть одинаково.

???
    О том, что не хорошо в использовании одномоментных снимков.
---

# Использование временных серий снимков

## Плюсы
 * Возможность анализа формы кривой сезонных изменений.
 * Возможность на базе статистических методов отфильтровать шумы, внесенные атмосферными
 и др. условиями.

## Минусы
 * Наличие регулярных временных рядов только для снимков с низким пространственным разрешением.
 * Сложность интерпретации данных.


???
    О том, что вообще появляется такая возможность -- использовать множество снимков
    на одну территорию (Landsat, MODIS и т.д.) -- накоплены многолетние ряды данных

---

class: center, middle

# Что дают временные ряды для разделения классов:

## пример из жизни

---

.center[
![Сырые кривые NDVI](img/raw_ndvi1.png)
]

Выборка значений «сырых» рядов NDVI, извлеченных непосредственно
из MOD13 для: 1 - залесенных березой болот; 2 -  зарастающих березой гарей.

---

.center[
![Восстановленные кривые NDVI](img/filtered_ndvi1.png)
]

Пример кривых NDVI после удаления высокочастотных компонент для: 1 - залесенных
березой болот; 2 -  зарастающих березой гарей.


---
## Разделимость классов по коэффициентам разложения в ряд Фурье

.center[
![Разделимость классов по коэффициентам разложения в ряд Фурье](img/separation.png)
]
Пример разделимости классов по первым коэффициентам разложения в ряд Фурье для:
1 - залесенных березой болот; 2 -  зарастающих березой гарей.

---

class: center, middle

# Обзор методов

---
# Два крайних случая 

Два крайних случая обработки мультивременных данных ДЗЗ для дальнейшей
классификации.

1. Восстановление анализируемого изображения (отражающей способности поверхности Земли
 или производных продуктов, например, NDVI) на произвольные даты. Далее классификация
 нескольких снимков за интересующие даты.
2. Извлечение признаков из снимков и классификация на их основе.

Переходные варианты - методы, позволяющие одновременно и восстанавливать изображения,
и извлекать признаки для классификации.


???
  Литературы много, для удобства ее изложения приведу классификацию с точки зрения
  реализации анализа разновременных снимков.
  1. Восстановление = очистка от шумов (облаков, теней и т.п.), т.е. получение "идеальной" поверхности.
  2. Если говорить именно о классификации, то очищенные изображения -- побочный продукт, не обязательно
  их создавать.


---

# Извлечение признаков

Классические алгоритмы извлечения или синтеза признаков:

 * Метод главных компонент;
 * Самоорганизующиеся карты Кохонена;

**Здесь эти вопросы не рассматриваются, методы упоминаются для полноты картины.**
---

class: center, middle

# Методы очистки от шумов

---
# Очистка от шумов фильтром Савицкого-Голея.

.footnote[Jönsson P., Eklundh L. TIMESAT - a program for analyzing time-series of
    satellite sensor data //Computers & Geosciences. – 2004. – Т. 30.]

.small[
Есть временной ряд `\((t_i, I_i)\)`, `\(i=1, 2, \dots, N\)`. В скользящем окне длиной `\(2m +1\)`
отсчетов производится аппроксимация многочленом
степени d, коэффициенты которого рассчитываются методом наименьших квадратов. Для центральной
точки окна по этому многочлену вычисляется значение, которое и будет результирующим
значением отфильтрованной кривой в данной точке. Затем окно сдвигается на одну позицию
и строится новая точка --- прогнозное значение кривой.
Процедура повторяется до тех пор, пока не закончится исходный ряд.
]

.center[
![Пример нескольких итераций работы фильтра](img/sav_gol.png
"Пример нескольких итераций работы фильтра")
]



---
# Подгонка параметрических кривых

Очень часто используется подгонка кривых методом наименьших квадратов.

Есть временной ряд `\((t_i, I_i)\)`, `\(i=1, 2, \dots, N\)`. Кривая моделируется
в форме:

`
$$
f(t) = c_1 \varphi_1(t) + c_2 \varphi_2(t) + \dots + c_M \varphi_M(t),
$$
`
где `\(\varphi_1(t)\)`, `\(\varphi_2(t)\)`, ..., `\(\varphi_M(t)\)`
произвольные базисные функции, а `\(c_1\)`, `\(c_2\)`, ..., `\(c_M\)` -
некоторые коэффициенты.

???
    Литературы много, мы рассматривает лишь то, что использовалось в нашем случае.
    Осветить основные статьи.




---

# TIMESAT

.footnote[Jönsson P., Eklundh L. TIMESAT - a program for analyzing time-series of
    satellite sensor data //Computers & Geosciences. – 2004. – Т. 30.]

Методом наименьших квадратов подгоняются полиномы совместно с гармоническими функциями (`\(\omega=6\pi/N\)`):
`
$$
\begin{split}
f(t) = & c_1 + c_2 t + c_3 t^2 + c_4 \sin(\omega t) + c_5 \cos(\omega t) + \\
       & c_6 \sin(2\omega t) + c_7 \cos(2\omega t) + c_8 \sin(3\omega t) + c_9 \cos(3\omega t)
\end{split}
$$
`

# Синтезирование изображений Landsat
.footnote[Zhu Z. et al. Generating synthetic Landsat images based on all
available Landsat data: Predicting Landsat surface reflectance at any given time
//Remote Sensing of Environment. – 2015. – Т. 162. – С. 67-83.]

`
$$
f_{simple}(t) = c_0 + c_1 t + c_2 \sin(\omega t) + c_3 \cos(\omega t)
$$
`

`
$$
\begin{split}
f_{advansed}(t) = & c_0 + c_1 t + c_2 \sin(\omega t) + c_3 \cos(\omega t) + \\
       & c_4 \sin(2\omega t) + c_5 \cos(2\omega t)
\end{split}
$$
`

`
$$
\begin{split}
f_{full}(t) = & c_0 + c_1 t + c_2 \sin(\omega t) + c_3 \cos(\omega t) + \\
       & c_4 \sin(2\omega t) + c_5 \cos(2\omega t) + c_6 \sin(3\omega t) + c_7 \cos(3\omega t)
\end{split}
$$
`


???


---
# Классификация на базе преобразования Фурье

.footnote[
Lhermitte S. et al. Hierarchical image segmentation based on similarity of NDVI time series
//Remote Sensing of Environment. – 2008. – Т. 112. – №. 2. – С. 506-521.
]
Дана функция `\(f(x)\)`, определенная на интервале `\(x\in (-\pi, \pi]\)`. Известно, что
ее можно разложить в ряд, состоящий из тригонометрических функций
(ограничения на `\(f(x)\)` очень слабые, на практике любая функция будет им удовлетворять):
`
$$
f(x) = \frac{a_0}2 + \sum_{n=0}^\infty (a_n\cos nx + b_n \sin nx)
$$
`
Легко показать, что коэффициенты ряда могут быть вычислены по формулам:
`
$$
a_n = \frac1{\pi} \int_{-\pi}^\pi f(x) \cos nx dx, \qquad n \ge 0
$$
`
`
$$
b_n = \frac1{\pi} \int_{-\pi}^\pi f(x) \sin nx dx, \qquad n>0
$$
`

Исходный интервал `\(x\in (-\pi, \pi]\)` может быть легко промасштабирован на произвольный симметричный отрезок `\([-L, L]\)`.

???
  По сути дела мы получаем почти такую же формулу, что и на предыдущих слайдах,
  за исключением линейного тренда.

  Но тут появляется новая идея -- использовать коэффициенты разложения как признаки
  для классификации.

  Коэффициентов разложения много, но для классификации можно выбрать не все, а
  только основные значимые, шумовые коэффициенты отбросить.


---

class: center, middle

# Модуль r.series.decompose для 
# GRASS GIS

---

# Зачем нужен модуль?

Нет открытых ГИС инструментов для очистки от шумов и разложения временных рядов
на компоненты.

 * TIMESAT: закрытая лицензия.
 * R, Python, Julia, ...: нужно программировать под свою задачу.


# Как используется этот модуль:

 * Фильтрация данных от шума.
 * Выделение коэффициентов разложения для последующей классификации.
 * Генерация кривых спектральных яркостей на заданную дату.

---
# Как устроен модуль

Методом наименьших квадратов подгоняется линейная функция совместно с гармоническими функциями: 
`
$$
\begin{split}
f(t) = & c_1 + c_2 t + c_4 \sin(\omega_1 t) + c_5 \cos(\omega_1 t) + \\
       & c_6 \sin(\omega_2 t) + c_7 \cos(\omega_2 t)+ \dots \\
	   & + c_{n-1} \sin(\omega_k t) + c_n \cos(\omega_k t)
\end{split}
$$
`

* Нет предопределенных частот у гармонических функций.
* Только линейный тренд (на данный момент, планируется изменить).

Входные данные:
 * Список растров -- временной ряд.
 * Список частот гармоник.


Выходные значения:
 * Растры коэффициентов `$$c_1, c_2, \dots, c_n.$$`
 * Растры отфильтрованных результатов ("очищенные" растры). 

---
# Установка модуля

### Необходимые в системе программы и библиотеки:

 * GRASS GIS 7
 * Библиотека SciPy для Python
 * Модуль GRASS r.mregression.series (доступен в addons)


### Установка

Модули доступны в GRASS addons, поэтому установка производится стандартными средствами 
через модуль g.extension

1. Установить r.mregression.series:
```bash
g.extension extension=r.mregression.series operation=add
```
2. Установить r.series.decompose: 
```bash
g.extension extension=r.series.decompose operation=add
```


---
# Параметры запуска

```bash
 r.series.decompose input=string[,string,...] result_prefix=string coef_prefix=string 
   timevar_prefix=string freq=value[,value,...] [--overwrite] [--help] [--verbose] [--quiet] [--ui]
```

* input список имен анализируемых растров.
* result_prefix префикс для имен результатов -- очищеных от шумов растров.
* coef_prefix префикс для имен растров с коэффициентами.
* timevar_prefix префикс для имен растров с объясняющими переменными (зависящими от времени). 
* freq список частот используемых гармоник.


**Последовательность действий**
1. Составить список анализируемых карт. Карты должны быть через равные временные интервалы. Если
это не так, то нужно вставить пустые растры (NULL).
2. Если в анализируемых растрах есть облака и тени, то лучше их эти области заполнить значением "нет данных"
(NULL).
3. Определиться с числом гармоник и их составом. (Обычно гармоники кратны числу сезонов).


```bash
r.series.decompose input=raster1,raster2,raster3,... \
	coef_prefix="coef." timevar_prefix="dec." result_pref="res." freq=3,6,9
```

---
# Результаты

Наиболее важные генерируемые данные (для предыдущего примера):

* Отфильтрованные растры res.raster1, res.raster2, res.raster3, ...
* **Растры коэффициентов:**  coef.const, coef.cos_fr3, coef.cos_fr3, coef.cos_fr6, coef.sin_fr6, coef.sin_fr9, coef.sin_fr9, coef.time

### Коэффициенты:

 * Классификация растительности:
   1. Коэффициенты описывают кривую изменения яркости или вегетативного индекса.
   2. Можно их использовать как признак ("канал") в процедурах классификации.
 * Генерация спектральных яркостей на требуемую дату.
   1. Пусть t -- интересующая дата.
   2. Подставим найденные коэффициенты и t в формулу: 
`
$$
\begin{split}
f(t) = & c_1 + c_2 t + c_4 \sin(\omega_1 t) + c_5 \cos(\omega_1 t) + \\
       & c_6 \sin(\omega_2 t) + c_7 \cos(\omega_2 t)+ \dots \\
	   & + c_{n-1} \sin(\omega_k t) + c_n \cos(\omega_k t)
\end{split}
$$
`
	в результате получим требуемую величину.



---
# Особенности работы

1. Использует много файлов (исходные серии растров, растры переменных, коэффициентов и т.д.).
   В операционной системе есть ограничения на количество одновременно открытых растров. Может
   появиться ошибка, связанная с лимитом на число открытых файлов. Ошибка обходится пустем увеличения
   значения этого параметра. (Linux: /etc/security/limits.conf)
2. Скорость работы. Зависит от числа гармоник, длины временных рядов и разрешения растров. 
   (И мощности компьютера, конечно же). На "обычном" ноутбуке серия из 46 растров 10 коэффициентов
   регион размером 25000 пикселей считается 5 минут.

---

# Выводы и планы на будущее

 Использование временных серий позволяет повысить точность картирования "трудных" классов => Необходимость в создании инструмента анализа 
 временных серий растров.   

# Планы на будущее
 * Оптимизация быстродействия. 
 * Параметры выбора членов полиномиального тренда.





    </textarea>
    <script src="remark-latest.min.js" type="text/javascript">
    </script>
    <script type="text/javascript">
      var slideshow = remark.create();
      // Setup MathJax
      MathJax.Hub.Config({
          tex2jax: {
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre']
          }
      });
      MathJax.Hub.Queue(function() {
          $(MathJax.Hub.getAllJax()).map(function(index, elem) {
              return(elem.SourceElement());
          }).parent().addClass('has-jax');
      });

      MathJax.Hub.Configured();
    </script>
  </body>
</html>
